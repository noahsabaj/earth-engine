//! Automatic WGSL generation from Rust types using encase
//! 
//! This module provides automatic generation of WGSL type definitions
//! from Rust types, eliminating manual WGSL string generation.

use std::collections::HashMap;
use encase::{ShaderType, ShaderSize};

/// Trait for types that can generate their WGSL representation
pub trait WgslType: ShaderType {
    /// Generate WGSL type definition
    fn wgsl_definition() -> String;
    
    /// Get the WGSL type name
    fn wgsl_type_name() -> &'static str;
}

/// WGSL type registry for managing generated types
pub struct WgslTypeRegistry {
    types: HashMap<String, String>,
    dependencies: HashMap<String, Vec<String>>,
}

impl WgslTypeRegistry {
    pub fn new() -> Self {
        Self {
            types: HashMap::new(),
            dependencies: HashMap::new(),
        }
    }
    
    /// Register a type for WGSL generation
    pub fn register<T: WgslType>(&mut self) {
        let type_name = T::wgsl_type_name();
        let definition = T::wgsl_definition();
        self.types.insert(type_name.to_string(), definition);
    }
    
    /// Generate complete WGSL with all registered types
    pub fn generate_wgsl(&self) -> String {
        let mut wgsl = String::new();
        
        // Header
        wgsl.push_str("// AUTO-GENERATED WGSL - DO NOT EDIT\n");
        wgsl.push_str("// Generated by Rust GPU type system\n\n");
        
        // Sort types by dependencies
        let sorted_types = self.topological_sort();
        
        // Generate definitions
        for type_name in sorted_types {
            if let Some(definition) = self.types.get(&type_name) {
                wgsl.push_str(definition);
                wgsl.push_str("\n\n");
            }
        }
        
        wgsl
    }
    
    /// Topological sort to handle dependencies
    fn topological_sort(&self) -> Vec<String> {
        // For now, return types in insertion order
        // TODO: Implement proper dependency resolution
        self.types.keys().cloned().collect()
    }
}

/// Macro to automatically implement WgslType for structs with ShaderType
#[macro_export]
macro_rules! impl_wgsl_type {
    ($type:ty, $wgsl_name:literal) => {
        impl $crate::gpu::wgsl_generator::WgslType for $type {
            fn wgsl_type_name() -> &'static str {
                $wgsl_name
            }
            
            fn wgsl_definition() -> String {
                // Use encase metadata to generate WGSL
                $crate::gpu::wgsl_generator::generate_struct_wgsl::<$type>($wgsl_name)
            }
        }
    };
}

/// Generate WGSL struct definition from encase metadata
pub fn generate_struct_wgsl<T: ShaderType + ShaderSize>(name: &str) -> String {
    let mut wgsl = format!("struct {} {{\n", name);
    
    // Get type metadata from encase
    let size = T::SHADER_SIZE.get();
    let alignment = T::min_size().get();
    
    // Add size/alignment comment
    wgsl.push_str(&format!("    // Size: {} bytes, Alignment: {} bytes\n", size, alignment));
    
    // TODO: Use encase's metadata to generate field definitions
    // For now, we'll need to handle specific types
    
    wgsl.push_str("}");
    wgsl
}

/// WGSL type mapping for common Rust types
pub fn rust_to_wgsl_type(rust_type: &str) -> &'static str {
    match rust_type {
        "u32" => "u32",
        "i32" => "i32",
        "f32" => "f32",
        "bool" => "bool",
        "[f32; 2]" => "vec2<f32>",
        "[f32; 3]" => "vec3<f32>",
        "[f32; 4]" => "vec4<f32>",
        "[u32; 2]" => "vec2<u32>",
        "[u32; 3]" => "vec3<u32>",
        "[u32; 4]" => "vec4<u32>",
        _ => "unknown",
    }
}

/// Builder for generating WGSL structs with proper alignment
pub struct WgslStructBuilder {
    name: String,
    fields: Vec<WgslField>,
    current_offset: u32,
}

#[derive(Clone)]
struct WgslField {
    name: String,
    wgsl_type: String,
    size: u32,
    alignment: u32,
}

impl WgslStructBuilder {
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            fields: Vec::new(),
            current_offset: 0,
        }
    }
    
    /// Add a field with automatic padding calculation
    pub fn add_field(&mut self, name: impl Into<String>, wgsl_type: impl Into<String>, size: u32, alignment: u32) -> &mut Self {
        // Calculate padding needed
        let padding = (alignment - (self.current_offset % alignment)) % alignment;
        
        // Add padding field if needed
        if padding > 0 {
            self.fields.push(WgslField {
                name: format!("_pad{}", self.fields.len()),
                wgsl_type: match padding {
                    4 => "u32".to_string(),
                    8 => "vec2<u32>".to_string(),
                    12 => "vec3<u32>".to_string(),
                    16 => "vec4<u32>".to_string(),
                    _ => format!("array<u32, {}>", padding / 4),
                },
                size: padding,
                alignment: 4,
            });
            self.current_offset += padding;
        }
        
        // Add the actual field
        self.fields.push(WgslField {
            name: name.into(),
            wgsl_type: wgsl_type.into(),
            size,
            alignment,
        });
        self.current_offset += size;
        
        self
    }
    
    /// Build the WGSL struct definition
    pub fn build(&self) -> String {
        let mut wgsl = format!("struct {} {{\n", self.name);
        
        for field in &self.fields {
            wgsl.push_str(&format!("    {}: {},\n", field.name, field.wgsl_type));
        }
        
        wgsl.push_str("}");
        wgsl
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_wgsl_struct_builder() {
        let mut builder = WgslStructBuilder::new("TestStruct");
        builder
            .add_field("id", "u32", 4, 4)
            .add_field("position", "vec3<f32>", 12, 16)
            .add_field("scale", "f32", 4, 4);
            
        let wgsl = builder.build();
        assert!(wgsl.contains("struct TestStruct"));
        assert!(wgsl.contains("_pad")); // Should have padding
        assert!(wgsl.contains("position: vec3<f32>"));
    }
}